import{_ as e,c as a,o as i,al as l}from"./chunks/framework.GtCa91sV.js";const k=JSON.parse('{"title":"RxJava 原理与源码解读","description":"","frontmatter":{},"headers":[],"relativePath":"android/主流库原理/RxJava原理.md","filePath":"android/主流库原理/RxJava原理.md","lastUpdated":1764061109000}'),n={name:"android/主流库原理/RxJava原理.md"};function r(d,s,t,o,h,c){return i(),a("div",null,[...s[0]||(s[0]=[l(`<h1 id="rxjava-原理与源码解读" tabindex="-1">RxJava 原理与源码解读 <a class="header-anchor" href="#rxjava-原理与源码解读" aria-label="Permalink to “RxJava 原理与源码解读”">​</a></h1><h2 id="核心概述" tabindex="-1">核心概述 <a class="header-anchor" href="#核心概述" aria-label="Permalink to “核心概述”">​</a></h2><p>RxJava 为响应式编程提供可组合的异步流抽象，通过 <code>Observable</code>/<code>Flowable</code> 等类型串联数据流处理、线程切换与错误控制。其底层依赖 <code>Scheduler</code>、装饰器模式的操作符链以及背压协议实现高扩展性。</p><h2 id="架构与关键角色" tabindex="-1">架构与关键角色 <a class="header-anchor" href="#架构与关键角色" aria-label="Permalink to “架构与关键角色”">​</a></h2><ul><li><strong>Observable/Observer</strong>：发布-订阅模型核心接口，<code>subscribe</code> 建立订阅关系。</li><li><strong>Operator</strong>：通过装饰器模式封装在 <code>Observable</code> 内，形成链式数据处理。</li><li><strong>Scheduler</strong>：抽象线程调度，常见实现有 <code>IoScheduler</code>、<code>ComputationScheduler</code>、<code>AndroidSchedulers.mainThread()</code> 等。</li><li><strong>Disposable</strong>：取消订阅/释放资源的契约。</li><li><strong>Flowable &amp; Backpressure</strong>：基于 Reactive Streams 规范，解决上下游速率不匹配。</li></ul><h2 id="订阅流程解析" tabindex="-1">订阅流程解析 <a class="header-anchor" href="#订阅流程解析" aria-label="Permalink to “订阅流程解析”">​</a></h2><ol><li>调用 <code>Observable.create</code> 返回 <code>ObservableOnSubscribe</code> 的包装对象。</li><li>链式调用操作符（map、flatMap 等）会生成新的 <code>Observable</code>，其 <code>source</code> 指向上一个节点。</li><li><code>subscribe</code> 时，从下游开始向上游依次调用 <code>subscribeActual</code>，形成责任链。</li><li>上游通过 <code>Observer.onNext</code> 逐个推送数据；<code>Scheduler</code> 通过 <code>ObservableSubscribeOn</code>、<code>ObservableObserveOn</code> 控制执行线程。</li></ol><div class="language-java line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ObservableSubscribeOn 的关键实现，展示线程切换原理</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> subscribeActual</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Observer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    final</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SubscribeOnObserver&lt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SubscribeOnObserver&lt;&gt;(observer); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 包装下游</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onSubscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parent);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Scheduler.Worker w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> scheduler.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createWorker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    parent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setDisposable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(w);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    w.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">schedule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">subscribe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parent)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在线程池中订阅上游</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="背压处理" tabindex="-1">背压处理 <a class="header-anchor" href="#背压处理" aria-label="Permalink to “背压处理”">​</a></h2><ul><li><code>Flowable</code> 通过 <code>Subscription.request(n)</code> 控制上游发送速率。</li><li><code>BackpressureStrategy</code> 决定缓存或丢弃策略，如 <code>BUFFER</code>、<code>DROP</code>、<code>LATEST</code>。</li><li>操作符在实现时需遵循请求协议，常见如 <code>FlowableFlatMap</code> 使用 <code>Queue</code> 与原子变量协调上下游。</li></ul><h2 id="错误与资源管理" tabindex="-1">错误与资源管理 <a class="header-anchor" href="#错误与资源管理" aria-label="Permalink to “错误与资源管理”">​</a></h2><ul><li>操作符默认遵循“终止即清理”原则，<code>onError</code> 或 <code>onComplete</code> 后自动释放订阅。</li><li><code>CompositeDisposable</code> 便于批量管理订阅，避免内存泄漏。</li><li><code>doOnError</code>、<code>retry</code> 等操作符提供错误监控与重试机制。</li></ul><h2 id="实践建议" tabindex="-1">实践建议 <a class="header-anchor" href="#实践建议" aria-label="Permalink to “实践建议”">​</a></h2><ul><li><strong>线程切换</strong>：<code>subscribeOn</code> 决定上游线程，<code>observeOn</code> 决定下游线程；遵循“多次 subscribeOn 仅首次生效，多次 observeOn 逐段切换”。</li><li><strong>背压策略选择</strong>：数据量大时优先使用 <code>Flowable</code>，并明确 <code>BackpressureStrategy</code> 以防 <code>MissingBackpressureException</code>。</li><li><strong>生命周期管理</strong>：在 Android 中结合 <code>AutoDispose</code>、<code>RxLifecycle</code> 或 ViewModel 的 <code>onCleared</code> 释放订阅。</li></ul><h2 id="调试与监控" tabindex="-1">调试与监控 <a class="header-anchor" href="#调试与监控" aria-label="Permalink to “调试与监控”">​</a></h2><ul><li>使用 <code>RxJavaPlugins.setErrorHandler</code> 捕获未处理错误。</li><li>借助 <code>RxJava2Debug</code> 或 <code>AssemblyTracking</code> 定位异常发生位置。</li><li>将关键流的订阅/取消写入日志，辅助排查线程切换或背压问题。</li></ul>`,16)])])}const b=e(n,[["render",r]]);export{k as __pageData,b as default};
