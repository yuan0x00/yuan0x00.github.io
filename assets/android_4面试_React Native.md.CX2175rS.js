import{_ as i,c as a,o as l,aj as e}from"./chunks/framework.BiF827kf.js";const c=JSON.parse('{"title":"React Native 面试高频考点大全","description":"","frontmatter":{},"headers":[],"relativePath":"android/4面试/React Native.md","filePath":"android/4面试/React Native.md","lastUpdated":1762951275000}'),n={name:"android/4面试/React Native.md"};function t(r,s,h,k,o,d){return l(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="react-native-面试高频考点大全" tabindex="-1">React Native 面试高频考点大全 <a class="header-anchor" href="#react-native-面试高频考点大全" aria-label="Permalink to “React Native 面试高频考点大全”">​</a></h1><h2 id="一、基础语法与核心概念-必考" tabindex="-1">一、基础语法与核心概念（必考） <a class="header-anchor" href="#一、基础语法与核心概念-必考" aria-label="Permalink to “一、基础语法与核心概念（必考）”">​</a></h2><h3 id="_1-组件与-hooks" tabindex="-1">1. 组件与 Hooks <a class="header-anchor" href="#_1-组件与-hooks" aria-label="Permalink to “1. 组件与 Hooks”">​</a></h3><ul><li><strong>函数组件 vs 类组件</strong>：React Native 中几乎全部使用函数组件。</li><li><strong>核心 Hooks 使用与区别</strong>： <ul><li><code>useState</code>：管理状态，注意闭包陷阱（推荐函数式更新）。</li><li><code>useEffect</code>：处理副作用，依赖数组控制执行时机。</li><li><code>useRef</code>：存储可变值或访问原生组件，修改不触发重渲染。</li></ul></li><li><strong>典型问题</strong>： <ul><li><code>useEffect</code> 依赖数组为空 <code>[]</code> 和不写有什么区别？ <ul><li><code>[]</code>：仅在 mount 时执行一次。</li><li>不写：每次渲染都执行（因依赖数组引用变化）。</li></ul></li><li>如何在 <code>useEffect</code> 中获取最新 state？ <ul><li>使用 <code>ref</code> 同步状态，或使用函数式更新（<code>setCount(prev =&gt; prev + 1)</code>）。</li></ul></li><li><code>useRef</code> 修改后为什么不触发重渲染？ <ul><li>因为 <code>ref.current</code> 不属于 React 响应式系统，React 不监听其变化。</li></ul></li></ul></li></ul><h3 id="_2-样式与布局" tabindex="-1">2. 样式与布局 <a class="header-anchor" href="#_2-样式与布局" aria-label="Permalink to “2. 样式与布局”">​</a></h3><ul><li><strong>Flexbox 布局</strong>：React Native 默认使用 Yoga 引擎实现 Flexbox。</li><li><strong>平台适配</strong>： <ul><li><code>Platform.OS === &#39;ios&#39;</code> / <code>&#39;android&#39;</code></li><li>文件扩展名：<code>Component.ios.js</code> / <code>Component.android.js</code></li></ul></li><li><strong>安全区域</strong>：使用 <code>SafeAreaView</code> 或 <code>react-native-safe-area-context</code> 的 <code>useSafeAreaInsets</code>。</li><li><strong>典型问题</strong>： <ul><li>RN 的 Flexbox 和 Web 有什么不同？ <ul><li>默认主轴是 <strong>column</strong>（Web 是 row）。</li><li>不支持 <code>flex-wrap: wrap</code> 的某些行为。</li></ul></li><li>如何适配刘海屏？ <ul><li>使用 <code>SafeAreaView</code> 包裹内容，或通过 <code>useSafeAreaInsets()</code> 动态设置 padding。</li></ul></li></ul></li></ul><h3 id="_3-导航-react-navigation" tabindex="-1">3. 导航（React Navigation） <a class="header-anchor" href="#_3-导航-react-navigation" aria-label="Permalink to “3. 导航（React Navigation）”">​</a></h3><ul><li><strong>核心导航器</strong>：Stack、Tab、Drawer。</li><li><strong>常用 Hook</strong>： <ul><li><code>useNavigation()</code>：在任意组件中获取导航对象。</li><li><code>useRoute()</code>：获取当前路由参数。</li><li><code>useFocusEffect()</code>：仅在页面聚焦时执行副作用（替代 <code>useEffect</code>）。</li></ul></li><li><strong>典型问题</strong>： <ul><li>如何在非页面组件中跳转？ <ul><li>使用 <code>useNavigation()</code> 获取 <code>navigation</code> 对象。</li></ul></li><li>如何监听页面聚焦/失焦？ <ul><li>使用 <code>useFocusEffect(useCallback(() =&gt; { ... }, []))</code>。</li></ul></li></ul></li></ul><hr><h2 id="二、原理与底层机制-中高级重点" tabindex="-1">二、原理与底层机制（中高级重点） <a class="header-anchor" href="#二、原理与底层机制-中高级重点" aria-label="Permalink to “二、原理与底层机制（中高级重点）”">​</a></h2><h3 id="_1-react-native-运行原理" tabindex="-1">1. React Native 运行原理 <a class="header-anchor" href="#_1-react-native-运行原理" aria-label="Permalink to “1. React Native 运行原理”">​</a></h3><ul><li><strong>Bridge 架构（旧）</strong>： <ul><li>JS 与原生通过 <strong>异步 Bridge</strong> 通信。</li><li>数据需 <strong>序列化为 JSON</strong>，存在性能瓶颈。</li></ul></li><li><strong>新架构（Fabric + TurboModules + JSI）</strong>： <ul><li><strong>JSI</strong>：JavaScript Interface，允许 JS 直接持有 C++ 对象引用，<strong>绕过序列化</strong>。</li><li><strong>Fabric</strong>：新渲染器，JS 可直接操作原生 UI，减少线程切换。</li><li><strong>TurboModules</strong>：按需加载原生模块，提升启动速度。</li></ul></li><li><strong>典型问题</strong>： <ul><li>RN 是 WebView 吗？和 Cordova 有什么区别？ <ul><li><strong>不是</strong>！RN 渲染的是 <strong>真实原生组件</strong>（如 <code>UIView</code>/<code>ViewGroup</code>），而 Cordova 是 WebView 渲染 HTML。</li></ul></li><li>新架构如何提升性能？ <ul><li>消除 Bridge 序列化开销，支持同步调用，UI 线程直接执行动画（如 Reanimated 2）。</li></ul></li></ul></li></ul><h3 id="_2-react-核心原理-fiber-架构" tabindex="-1">2. React 核心原理（Fiber 架构） <a class="header-anchor" href="#_2-react-核心原理-fiber-架构" aria-label="Permalink to “2. React 核心原理（Fiber 架构）”">​</a></h3><ul><li><strong>Fiber 节点</strong>：每个组件对应一个 Fiber 对象，包含 <code>memoizedState</code>（hooks 链表头）。</li><li><strong>Hooks 存储</strong>： <ul><li><code>useState</code> 的状态存储在 <strong>hooks 链表</strong> 中，每个 hook 节点包含 <code>memoizedState</code>（值）和 <code>queue</code>（更新队列）。</li><li>Fiber 的 <code>memoizedState</code> 指向链表头。</li></ul></li><li><strong>更新流程</strong>： <ul><li>调用 <code>setCount</code> → 将更新加入 <code>queue.pending</code> → 下次 render 时处理。</li></ul></li><li><strong>典型问题</strong>： <ul><li><code>useState</code> 的状态存在哪里？ <ul><li>存在于 Fiber 节点的 <code>memoizedState</code> 所指向的 <strong>hooks 链表</strong> 中。</li></ul></li><li>为什么 Hook 不能在条件语句中使用？ <ul><li>React 依赖 <strong>调用顺序</strong> 匹配 hooks，顺序错乱会导致状态错乱。</li></ul></li></ul></li></ul><h3 id="_3-线程模型" tabindex="-1">3. 线程模型 <a class="header-anchor" href="#_3-线程模型" aria-label="Permalink to “3. 线程模型”">​</a></h3><ul><li><strong>JS 线程</strong>：执行 JavaScript 逻辑。</li><li><strong>UI 线程</strong>：渲染原生视图（iOS Main Thread / Android UI Thread）。</li><li><strong>Shadow Thread</strong>：使用 Yoga 计算布局。</li><li><strong>通信</strong>：旧架构通过 Bridge 异步通信；新架构通过 JSI 直接调用。</li></ul><hr><h2 id="三、性能优化-实战重点" tabindex="-1">三、性能优化（实战重点） <a class="header-anchor" href="#三、性能优化-实战重点" aria-label="Permalink to “三、性能优化（实战重点）”">​</a></h2><h3 id="_1-列表优化-flatlist" tabindex="-1">1. 列表优化（FlatList） <a class="header-anchor" href="#_1-列表优化-flatlist" aria-label="Permalink to “1. 列表优化（FlatList）”">​</a></h3><ul><li><strong>关键配置</strong>： <ul><li><code>initialNumToRender</code>：首屏渲染数量。</li><li><code>maxToRenderPerBatch</code>：每批渲染数量。</li><li><code>windowSize</code>：渲染窗口大小（默认 21 屏）。</li><li><code>getItemLayout</code>：已知高度时跳过测量。</li></ul></li><li><strong>避免重复渲染</strong>： <ul><li><code>renderItem</code> 使用 <code>useCallback</code>。</li><li>子组件使用 <code>React.memo</code>。</li></ul></li><li><strong>图片优化</strong>：使用 <code>react-native-fast-image</code> 实现缓存。</li></ul><h3 id="_2-渲染优化" tabindex="-1">2. 渲染优化 <a class="header-anchor" href="#_2-渲染优化" aria-label="Permalink to “2. 渲染优化”">​</a></h3><ul><li><strong>避免 inline 对象/function</strong>：<div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ❌ 每次渲染都创建新对象</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Child</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> style</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{{ color: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;red&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }} </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onPress</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}} /&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ✅ 提前定义</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> style</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useMemo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ({ color: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;red&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }), []);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handlePress</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {}, []);</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li><li><strong>合理使用 useMemo/useCallback</strong>：仅当计算昂贵或用于 props 时使用。</li></ul><h3 id="_3-内存与启动优化" tabindex="-1">3. 内存与启动优化 <a class="header-anchor" href="#_3-内存与启动优化" aria-label="Permalink to “3. 内存与启动优化”">​</a></h3><ul><li><strong>内存泄漏</strong>：确保清理定时器、监听器（<code>useEffect</code> 返回函数）。</li><li><strong>启动优化</strong>： <ul><li>启用 <strong>Hermes 引擎</strong>（更快的启动和更低内存）。</li><li>配置原生 <strong>Splash Screen</strong> 掩盖白屏。</li><li>首屏只加载必要资源。</li></ul></li></ul><hr><h2 id="四、工程化与调试能力" tabindex="-1">四、工程化与调试能力 <a class="header-anchor" href="#四、工程化与调试能力" aria-label="Permalink to “四、工程化与调试能力”">​</a></h2><h3 id="_1-调试技巧" tabindex="-1">1. 调试技巧 <a class="header-anchor" href="#_1-调试技巧" aria-label="Permalink to “1. 调试技巧”">​</a></h3><ul><li><strong>JS 调试</strong>：Chrome DevTools、Flipper。</li><li><strong>原生日志</strong>： <ul><li>Android：<code>adb logcat</code></li><li>iOS：Xcode Console 或 Console.app</li></ul></li><li><strong>性能分析</strong>： <ul><li>React DevTools Profiler（组件渲染）</li><li>Flipper Performance Monitor（FPS、内存）</li></ul></li></ul><h3 id="_2-打包与发布" tabindex="-1">2. 打包与发布 <a class="header-anchor" href="#_2-打包与发布" aria-label="Permalink to “2. 打包与发布”">​</a></h3><ul><li><strong>Android</strong>：生成 APK/AAB，配置签名，启用 Proguard 混淆。</li><li><strong>iOS</strong>：Archive → TestFlight → App Store。</li><li><strong>热更新</strong>： <ul><li>方案：CodePush、Expo Updates。</li><li><strong>注意</strong>：苹果禁止通过热更新改变核心功能。</li></ul></li></ul><h3 id="_3-测试" tabindex="-1">3. 测试 <a class="header-anchor" href="#_3-测试" aria-label="Permalink to “3. 测试”">​</a></h3><ul><li><strong>单元测试</strong>：Jest</li><li><strong>组件测试</strong>：React Native Testing Library</li><li><strong>E2E 测试</strong>：Detox</li></ul><hr><h2 id="五、原生能力扩展-中高级加分项" tabindex="-1">五、原生能力扩展（中高级加分项） <a class="header-anchor" href="#五、原生能力扩展-中高级加分项" aria-label="Permalink to “五、原生能力扩展（中高级加分项）”">​</a></h2><h3 id="_1-原生模块开发" tabindex="-1">1. 原生模块开发 <a class="header-anchor" href="#_1-原生模块开发" aria-label="Permalink to “1. 原生模块开发”">​</a></h3><ul><li><strong>iOS</strong>：Objective-C/Swift 编写 <code>RCT_EXPORT_METHOD</code></li><li><strong>Android</strong>：Java/Kotlin 继承 <code>ReactContextBaseJavaModule</code></li><li><strong>通信</strong>：通过 <code>@ReactMethod</code> 暴露方法给 JS。</li></ul><h3 id="_2-高级第三方库原理" tabindex="-1">2. 高级第三方库原理 <a class="header-anchor" href="#_2-高级第三方库原理" aria-label="Permalink to “2. 高级第三方库原理”">​</a></h3><ul><li><strong><code>react-native-reanimated</code></strong>： <ul><li>动画在 <strong>UI 线程</strong> 执行（通过 Worklet + JSI）。</li><li>支持手势驱动复杂交互动画。</li></ul></li><li><strong><code>react-native-gesture-handler</code></strong>： <ul><li>原生手势识别，避免 JS 线程阻塞。</li></ul></li><li><strong><code>@react-native-async-storage/async-storage</code></strong>： <ul><li>封装原生存储（iOS: UserDefaults, Android: SharedPreferences）。</li></ul></li></ul><hr><h2 id="六、项目经验与架构设计-高级重点" tabindex="-1">六、项目经验与架构设计（高级重点） <a class="header-anchor" href="#六、项目经验与架构设计-高级重点" aria-label="Permalink to “六、项目经验与架构设计（高级重点）”">​</a></h2><h3 id="_1-状态管理" tabindex="-1">1. 状态管理 <a class="header-anchor" href="#_1-状态管理" aria-label="Permalink to “1. 状态管理”">​</a></h3><ul><li><strong>轻量级</strong>：<code>Context + useReducer</code></li><li><strong>中大型项目</strong>：Redux Toolkit、Zustand</li><li><strong>原则</strong>：局部状态用 <code>useState</code>，全局状态才用状态管理库。</li></ul><h3 id="_2-网络与数据层" tabindex="-1">2. 网络与数据层 <a class="header-anchor" href="#_2-网络与数据层" aria-label="Permalink to “2. 网络与数据层”">​</a></h3><ul><li><strong>封装请求</strong>：统一拦截、错误处理。</li><li><strong>数据缓存</strong>：使用 <code>react-query</code> 或 <code>SWR</code> 管理服务端状态。</li><li><strong>离线支持</strong>：本地缓存 + 同步队列。</li></ul><h3 id="_3-架构设计" tabindex="-1">3. 架构设计 <a class="header-anchor" href="#_3-架构设计" aria-label="Permalink to “3. 架构设计”">​</a></h3><ul><li><strong>组件化</strong>：按功能拆分 UI 组件、业务组件。</li><li><strong>多环境配置</strong>：<code>.env.development</code> / <code>.env.production</code></li><li><strong>监控</strong>：集成 Sentry/Bugsnag 捕获 JS 和原生错误。</li></ul><hr><h2 id="七、高频手写题" tabindex="-1">七、高频手写题 <a class="header-anchor" href="#七、高频手写题" aria-label="Permalink to “七、高频手写题”">​</a></h2><h3 id="_1-防抖-hook" tabindex="-1">1. 防抖 Hook <a class="header-anchor" href="#_1-防抖-hook" aria-label="Permalink to “1. 防抖 Hook”">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useDebounce</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">delay</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">debouncedValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setDebouncedValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> handler</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setDebouncedValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(value), delay);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> clearTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(handler);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [value, delay]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> debouncedValue;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_2-异步存储-hook" tabindex="-1">2. 异步存储 Hook <a class="header-anchor" href="#_2-异步存储-hook" aria-label="Permalink to “2. 异步存储 Hook”">​</a></h3><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useAsyncStorage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">initialValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(initialValue);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  useEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    AsyncStorage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">v</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(v </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> initialValue));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [key]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> setStoredValue</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">async</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    await</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> AsyncStorage.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, val);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    setValue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(val);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, [key]);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [value, setStoredValue];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h3 id="_3-优化的-flatlist" tabindex="-1">3. 优化的 FlatList <a class="header-anchor" href="#_3-优化的-flatlist" aria-label="Permalink to “3. 优化的 FlatList”">​</a></h3><div class="language-jsx line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> renderItem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> useCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(({ </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MemoizedItem</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{item} /&gt;, []);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FlatList</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{data}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  renderItem</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{renderItem}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  keyExtractor</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">item</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> item.id}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  initialNumToRender</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  maxToRenderPerBatch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>`,54)])])}const g=i(n,[["render",t]]);export{c as __pageData,g as default};
