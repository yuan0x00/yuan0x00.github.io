import{_ as a,c as i,o as s,aj as t}from"./chunks/framework.BiF827kf.js";const g=JSON.parse('{"title":"ViewPager2 原理与源码解读","description":"","frontmatter":{},"headers":[],"relativePath":"android/2主流库源码/Jetpack/ViewPager2原理源码.md","filePath":"android/2主流库源码/Jetpack/ViewPager2原理源码.md","lastUpdated":1762951116000}'),n={name:"android/2主流库源码/Jetpack/ViewPager2原理源码.md"};function r(l,e,o,d,c,h){return s(),i("div",null,[...e[0]||(e[0]=[t(`<h1 id="viewpager2-原理与源码解读" tabindex="-1">ViewPager2 原理与源码解读 <a class="header-anchor" href="#viewpager2-原理与源码解读" aria-label="Permalink to “ViewPager2 原理与源码解读”">​</a></h1><h2 id="核心概述" tabindex="-1">核心概述 <a class="header-anchor" href="#核心概述" aria-label="Permalink to “核心概述”">​</a></h2><p>ViewPager2 是 ViewPager 的升级版，基于 RecyclerView 实现横向/纵向分页。得益于 RecyclerView 的复用机制与 DiffUtil 支持，ViewPager2 提供更灵活的页面管理、RTL 支持、可变高度以及与 <code>FragmentStateAdapter</code> 的深度整合。</p><h2 id="架构组成" tabindex="-1">架构组成 <a class="header-anchor" href="#架构组成" aria-label="Permalink to “架构组成”">​</a></h2><ul><li><strong>RecyclerView + LinearLayoutManager</strong>：内部以横向或纵向的 LayoutManager 布局页面。</li><li><strong>ScrollEventAdapter</strong>：监听滚动事件，转换为页面位移与状态回调。</li><li><strong>FakeDrag</strong>：通过 <code>fakeDragBy</code> 实现代码驱动的拖拽效果。</li><li><strong>PageTransformerAdapter</strong>：桥接页面动画，与 <code>ViewPager.PageTransformer</code> 兼容。</li><li><strong>FragmentStateAdapter</strong>：官方提供的 Fragment 适配器，管理 Fragment 的创建、销毁与状态保存。</li></ul><h2 id="页面切换流程" tabindex="-1">页面切换流程 <a class="header-anchor" href="#页面切换流程" aria-label="Permalink to “页面切换流程”">​</a></h2><ol><li>调用 <code>setAdapter</code> 后，内部创建 <code>PagerSnapHelper</code> 保证一次滚动停留在整页。</li><li>用户滑动或调用 <code>setCurrentItem</code> 时，<code>RecyclerView</code> 触发滚动，<code>ScrollEventAdapter</code> 计算偏移量与方向。</li><li><code>ScrollEventAdapter</code> 更新内部状态（<code>SCROLL_STATE_DRAGGING</code>/<code>SETTLING</code>/<code>IDLE</code>），并回调 <code>OnPageChangeCallback</code>。</li><li>RecyclerView 完成滚动后，<code>notifyDatasetChanged</code> 或差分更新会触发页面重建或复用。</li></ol><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ViewPager2 设置当前页核心实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setCurrentItemInternal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(item: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, smoothScroll: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dataSetChangeObserver.isInProgress ? pendingCurrentItem : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">clampItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (smoothScroll) recyclerView.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">smoothScrollToPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> recyclerView.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">scrollToPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    scrollEventAdapter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">notifyProgrammaticScroll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(target, smoothScroll)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="fragmentstateadapter-工作机制" tabindex="-1">FragmentStateAdapter 工作机制 <a class="header-anchor" href="#fragmentstateadapter-工作机制" aria-label="Permalink to “FragmentStateAdapter 工作机制”">​</a></h2><ul><li>使用 <code>LongSparseArray&lt;Fragment&gt;</code> 记录已创建的 Fragment，Key 为 itemId。</li><li><code>createFragment(position)</code> 由开发者实现，Adapter 在 <code>onBindViewHolder</code> 时确保 Fragment 附着到 <code>FragmentTransaction</code>。</li><li>使用 <code>FragmentStateManager</code> 保存/恢复状态，在生命周期边界调用 <code>saveState</code>、<code>restoreState</code>，支持 Configuration Change。</li></ul><h2 id="关键源码细节" tabindex="-1">关键源码细节 <a class="header-anchor" href="#关键源码细节" aria-label="Permalink to “关键源码细节”">​</a></h2><ul><li><strong>OffscreenPageLimit</strong>：通过 <code>RecyclerView.setItemViewCacheSize</code> 控制预加载页面数量，默认 1。</li><li><strong>UserInputEnabled</strong>：封装 <code>RecyclerView.isLayoutFrozen</code> 控制手势是否生效。</li><li><strong>NestedScrolling</strong>：借助 RecyclerView 的嵌套滚动实现与 CoordinatorLayout、AppBarLayout 的联动。</li><li><strong>DiffUtil 支持</strong>：使用 <code>ListAdapter</code> 或手动提交 <code>notifyItemRange</code>，页面内容可高效更新。</li></ul><h2 id="实践建议" tabindex="-1">实践建议 <a class="header-anchor" href="#实践建议" aria-label="Permalink to “实践建议”">​</a></h2><ul><li>对 Fragment 页面使用 <code>FragmentStateAdapter</code>，结合 <code>getItemId</code> 与 <code>containsItem</code> 实现稳定 ID，减少重建。</li><li>对纯 View 页面可自定义 RecyclerView.Adapter，复用普通 ViewHolder 提升性能。</li><li>使用 <code>registerOnPageChangeCallback</code> 监听页面滚动，与 TabLayout 通过 <code>TabLayoutMediator</code> 联动。</li><li>如需可变高度，开启 <code>setOrientation</code> 为 <code>VERTICAL</code> 或结合 <code>WrapContentViewPager</code> 方案动态测量。</li></ul><h2 id="风险与调试" tabindex="-1">风险与调试 <a class="header-anchor" href="#风险与调试" aria-label="Permalink to “风险与调试”">​</a></h2><ul><li><strong>状态丢失</strong>：提交 Fragment 事务时机不当会抛出 <code>IllegalStateException</code>，确保在主线程并在生命周期安全期调用。</li><li><strong>动画冲突</strong>：自定义 PageTransformer 需避免直接修改 alpha/translation 导致闪烁；对 Fragment 使用 <code>setRetainInstance</code> 已弃用，应改为 ViewModel。</li><li>调试可启用 RecyclerView 日志或使用 FragmentTransaction#setMaxLifecycle 观察生命周期变更。</li></ul>`,16)])])}const k=a(n,[["render",r]]);export{g as __pageData,k as default};
