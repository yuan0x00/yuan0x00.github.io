import{_ as i,c as s,o as a,al as l}from"./chunks/framework.GtCa91sV.js";const k=JSON.parse('{"title":"ViewModel 原理与源码解读","description":"","frontmatter":{},"headers":[],"relativePath":"android/主流库原理/Jetpack/ViewModel原理源码.md","filePath":"android/主流库原理/Jetpack/ViewModel原理源码.md","lastUpdated":1764061109000}'),n={name:"android/主流库原理/Jetpack/ViewModel原理源码.md"};function t(d,e,o,r,h,c){return a(),s("div",null,[...e[0]||(e[0]=[l(`<h1 id="viewmodel-原理与源码解读" tabindex="-1">ViewModel 原理与源码解读 <a class="header-anchor" href="#viewmodel-原理与源码解读" aria-label="Permalink to “ViewModel 原理与源码解读”">​</a></h1><h2 id="核心概述" tabindex="-1">核心概述 <a class="header-anchor" href="#核心概述" aria-label="Permalink to “核心概述”">​</a></h2><p>ViewModel 是 Jetpack 提供的状态持有者，旨在跨越配置变更（如旋转）保留 UI 状态。通过 <code>ViewModelStore</code> 管理实例缓存、<code>Factory</code> 实现延迟创建、<code>SavedStateHandle</code> 支持进程重启恢复，ViewModel 成为 MVVM 架构的核心中介。</p><h2 id="架构组成" tabindex="-1">架构组成 <a class="header-anchor" href="#架构组成" aria-label="Permalink to “架构组成”">​</a></h2><ul><li><strong>ViewModel</strong>：抽象基类，暴露 <code>onCleared</code> 生命周期方法。</li><li><strong>ViewModelStore</strong>：维护 <code>Map&lt;String, ViewModel&gt;</code>，按作用域（Activity/Fragment）缓存实例。</li><li><strong>ViewModelProvider</strong>：对外暴露获取入口，协调 <code>ViewModelStore</code> 与 <code>Factory</code>。</li><li><strong>Factory</strong>：自定义构造逻辑，常用实现包括 <code>NewInstanceFactory</code>、<code>AndroidViewModelFactory</code>、<code>AbstractSavedStateViewModelFactory</code>。</li><li><strong>SavedStateHandleController</strong>：与 <code>SavedStateRegistry</code> 协同，在进程被杀后恢复关键数据。</li></ul><h2 id="创建与获取流程" tabindex="-1">创建与获取流程 <a class="header-anchor" href="#创建与获取流程" aria-label="Permalink to “创建与获取流程”">​</a></h2><ol><li><code>ViewModelProvider(owner, factory).get(FooViewModel::class.java)</code> 首先获取 <code>ViewModelStore</code>。</li><li><code>store.get(key)</code> 若命中直接返回；否则调用 <code>factory.create(modelClass)</code> 创建实例。</li><li>创建后的 ViewModel 会注册 <code>SavedStateHandleController</code>（若支持），并存入 <code>store.put(key, viewModel)</code>。</li><li>当宿主销毁（如 Activity finish）时，<code>ViewModelStore.clear()</code> 调用每个 ViewModel 的 <code>onCleared()</code>。</li></ol><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ViewModelProvider 获取流程核心实现</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ViewModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, modelClass: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Class</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (modelClass.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isInstance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(viewModel)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 创建新实例</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    viewModel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> factory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(modelClass)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    store.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">put</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, viewModel)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> viewModel</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="关键源码细节" tabindex="-1">关键源码细节 <a class="header-anchor" href="#关键源码细节" aria-label="Permalink to “关键源码细节”">​</a></h2><ul><li><strong>键生成策略</strong>：<code>ViewModelProvider</code> 默认使用 <code>DefaultKey</code>（<code>canonicalName:ViewModel</code>），Fragment 则基于 <code>FragmentManagerViewModel</code> 生成带索引的 Key，防止冲突。</li><li><strong>SavedState 支持</strong>：<code>AbstractSavedStateViewModelFactory</code> 从 <code>SavedStateRegistry</code> 读取 Bundle，构建 <code>SavedStateHandle</code> 注入 ViewModel。</li><li><strong>作用域传播</strong>：<code>Fragment</code> 的 ViewModel 可通过 <code>activityViewModels()</code> 共享父级 <code>ViewModelStore</code>，实现跨 Fragment 状态共享。</li><li><strong>生命周期解耦</strong>：ViewModel 不直接感知 Activity 生命周期，仅在 <code>onCleared</code> 收尾，确保逻辑层不泄漏 UI 引用。</li></ul><h2 id="实践建议" tabindex="-1">实践建议 <a class="header-anchor" href="#实践建议" aria-label="Permalink to “实践建议”">​</a></h2><ul><li>在构造函数注入 Repository、UseCase，结合 Hilt/Koin 自动提供依赖。</li><li>使用 <code>ViewModelScope</code> 运行协程，确保在 <code>onCleared</code> 时取消，避免内存泄漏。</li><li>合理划分 ViewModel 责任边界，对列表分页、表单状态等使用单一来源真相（Single Source of Truth）。</li><li>对复杂状态使用 <code>StateFlow</code> / <code>MutableStateFlow</code> 或 <code>MutableSharedFlow</code> 搭配 LiveData 暴露。</li></ul><h2 id="风险与调试" tabindex="-1">风险与调试 <a class="header-anchor" href="#风险与调试" aria-label="Permalink to “风险与调试”">​</a></h2><ul><li><strong>作用域错误</strong>：错误使用 <code>activityViewModels</code> 会导致多个页面共享状态，应明确生命周期归属。</li><li><strong>进程重启</strong>：<code>SavedStateHandle</code> 仅持久化 <code>Bundle</code> 支持类型，复杂对象需自行序列化。</li><li>调试可在 <code>onCleared</code> 中打印日志，确认 ViewModel 生命周期是否符合预期。</li></ul>`,14)])])}const g=i(n,[["render",t]]);export{k as __pageData,g as default};
