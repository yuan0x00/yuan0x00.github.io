import{_ as i,c as a,o as t,aj as e}from"./chunks/framework.BiF827kf.js";const A=JSON.parse('{"title":"JVM 与 ART 核心对比","description":"","frontmatter":{},"headers":[],"relativePath":"android/1语言与基础/Jvm对比Art.md","filePath":"android/1语言与基础/Jvm对比Art.md","lastUpdated":1762951275000}'),r={name:"android/1语言与基础/Jvm对比Art.md"};function o(n,l,d,s,u,c){return t(),a("div",null,[...l[0]||(l[0]=[e('<h1 id="jvm-与-art-核心对比" tabindex="-1">JVM 与 ART 核心对比 <a class="header-anchor" href="#jvm-与-art-核心对比" aria-label="Permalink to “JVM 与 ART 核心对比”">​</a></h1><h2 id="_1-背景概述" tabindex="-1">1. 背景概述 <a class="header-anchor" href="#_1-背景概述" aria-label="Permalink to “1. 背景概述”">​</a></h2><ul><li><strong>JVM（Java Virtual Machine）</strong>：起源于桌面与服务器领域，依赖字节码解释以及 JIT（Just-In-Time）编译，以跨平台与生态完善著称。</li><li><strong>Dalvik</strong>：Android 早期使用的寄宿虚拟机，面向资源受限环境优化，以字节码解释+JIT 为主。</li><li><strong>ART（Android Runtime）</strong>：Android 5.0 起默认运行时，以 AOT（Ahead-Of-Time）预编译为核心，同时引入 Profile-guided JIT 与混合编译策略，以移动端体验为优先。</li></ul><h2 id="_2-架构与执行模型" tabindex="-1">2. 架构与执行模型 <a class="header-anchor" href="#_2-架构与执行模型" aria-label="Permalink to “2. 架构与执行模型”">​</a></h2><table tabindex="0"><thead><tr><th>维度</th><th>JVM</th><th>ART</th></tr></thead><tbody><tr><td>字节码格式</td><td><code>.class</code> 文件，面向 JVM 指令集</td><td><code>.dex</code> 文件，合并多 <code>class</code>，面向寄存器架构</td></tr><tr><td>编译策略</td><td>解释 + JIT（C2/C1 编译器），HotSpot 驱动</td><td>安装期 AOT + 运行期 Profile JIT + Interpreter，支持混合模式</td></tr><tr><td>目标平台</td><td>桌面/服务器，硬件资源充裕</td><td>移动设备，资源与能耗受限</td></tr><tr><td>优化焦点</td><td>吞吐量、长期运行性能</td><td>启动速度、能效、包体积、交互流畅度</td></tr></tbody></table><h2 id="_3-编译流程对比" tabindex="-1">3. 编译流程对比 <a class="header-anchor" href="#_3-编译流程对比" aria-label="Permalink to “3. 编译流程对比”">​</a></h2><ol><li><strong>安装阶段</strong><ul><li>JVM：无需 AOT，直接加载 <code>.class</code> 或 <code>.jar</code>。</li><li>ART：在应用安装或系统更新时执行 <code>dex2oat</code>，生成 OAT/ELF 文件，降低首次启动开销。</li></ul></li><li><strong>运行阶段</strong><ul><li>JVM：类加载→解释执行→热点代码触发 JIT→生成本地代码；长时间运行的服务越受益。</li><li>ART： <ul><li>冷启动优先使用 AOT 结果；</li><li>运行过程中 Profile 收集真实使用轨迹；</li><li>后台编译服务针对热点代码做 JIT 或增量 AOT，兼顾体积与性能。</li></ul></li></ul></li><li><strong>升级/补丁</strong><ul><li>JVM：热部署/类重载相对灵活。</li><li>ART：系统更新需重建 OAT；对即时修复依赖 Instant Run、Dynamic Delivery 等机制。</li></ul></li></ol><h2 id="_4-内存管理与垃圾回收" tabindex="-1">4. 内存管理与垃圾回收 <a class="header-anchor" href="#_4-内存管理与垃圾回收" aria-label="Permalink to “4. 内存管理与垃圾回收”">​</a></h2><ul><li><strong>JVM</strong><ul><li>分代堆结构（Young/Old/Metaspace），GC 算法丰富（Serial、Parallel、CMS、G1、ZGC、Shenandoah）。</li><li>注重吞吐与停顿的平衡，可调控参数多，但配置复杂。</li></ul></li><li><strong>ART</strong><ul><li>统一堆布局，以移动端低内存为约束；支持 Concurrent Copying、Generational CC、Region-based GC。</li><li>GC 停顿时间更短，配合写屏障、TLA（Thread Local Allocation）降低分配成本。</li><li>运行期根据设备内存级别动态调优（Low-RAM 模式等）。</li></ul></li></ul><h2 id="_5-性能与体验" tabindex="-1">5. 性能与体验 <a class="header-anchor" href="#_5-性能与体验" aria-label="Permalink to “5. 性能与体验”">​</a></h2><ul><li><strong>启动速度</strong>：ART 通过安装期 AOT + 预热 Profile 显著降低冷启动延迟；JVM 初次运行依赖解释，Warm-up 时间更长。</li><li><strong>执行效率</strong>：JVM 在数据中心场景具备更强硬件支撑，JIT 优化充分；ART 在移动端通过热点编译与指令级优化（如 Quickening）满足交互需求。</li><li><strong>能耗</strong>：ART 减少运行期编译与解释开销，对电量敏感场景更友好。</li><li><strong>包体积</strong>：ART 需附带预编译产物（OAT/VDex），但引入 App Bundle、Dynamic Feature 后可按需下发；JVM 仅分发字节码。</li></ul><h2 id="_6-调试、诊断与工具链" tabindex="-1">6. 调试、诊断与工具链 <a class="header-anchor" href="#_6-调试、诊断与工具链" aria-label="Permalink to “6. 调试、诊断与工具链”">​</a></h2><ul><li><strong>JVM</strong>： <ul><li>工具成熟：JMX、JFR、VisualVM、Mission Control 等支持实时监控、Heap Dump、Thread Dump。</li><li>类加载器与反射机制灵活，利于动态代理与 AOP。</li></ul></li><li><strong>ART</strong>： <ul><li>Android Studio + ADB 提供 Profiling、Heap Dump、Method Tracing；</li><li>ART Runtime 提供 <code>perfetto</code>、<code>systrace</code>、<code>simpleperf</code> 等端侧分析工具；</li><li>Instant Run 被 App Deployment 替代，利用多进程沙箱保障安全；</li><li>调试需适配多架构（ARM/ARM64/x86），Native 混合调试更常见。</li></ul></li></ul><h2 id="_7-兼容性与生态" tabindex="-1">7. 兼容性与生态 <a class="header-anchor" href="#_7-兼容性与生态" aria-label="Permalink to “7. 兼容性与生态”">​</a></h2><ul><li><strong>字节码兼容</strong>：JVM 执行标准 Java 字节码；ART 基于 DEX，需通过 D8/R8 将 <code>.class</code> 转换。</li><li><strong>语言支持</strong>： <ul><li>JVM：支持 Scala、Kotlin、Groovy 等多 JVM 语言。</li><li>ART：Android 官方支持 Java/Kotlin，经 DEX 工具链适配，支持部分 JVM 语言（需 Dexing 兼容）。</li></ul></li><li><strong>平台差异</strong>： <ul><li>JVM 针对统一的服务器硬件；</li><li>ART 面向碎片化 Android 设备，需考虑 ABI、屏幕密度与系统版本差异。</li></ul></li></ul><h2 id="_8-安全性与沙箱" tabindex="-1">8. 安全性与沙箱 <a class="header-anchor" href="#_8-安全性与沙箱" aria-label="Permalink to “8. 安全性与沙箱”">​</a></h2><ul><li>JVM：依赖 Security Manager（JDK 17 起被弃用）、ClassLoader 隔离与权限策略。</li><li>ART： <ul><li>结合 Android 应用沙箱（UID 隔离）、SELinux、权限模型；</li><li>使用签名校验与 Verified Boot 保障运行时完整性；</li><li>DEX 验证 + OAT 校验防止字节码注入。</li></ul></li></ul><h2 id="_9-选型与迁移建议" tabindex="-1">9. 选型与迁移建议 <a class="header-anchor" href="#_9-选型与迁移建议" aria-label="Permalink to “9. 选型与迁移建议”">​</a></h2><ul><li><strong>选型思路</strong><ul><li>Android 端应用必须运行在 ART 上，无法直接替换；</li><li>服务器/桌面端服务仍应选择 JVM（HotSpot、OpenJ9 等）。</li></ul></li><li><strong>跨平台共享代码</strong><ul><li>可通过 Kotlin Multiplatform、KMP 插件，将核心逻辑在 JVM/ART 之间共享，再针对平台差异做封装。</li><li>公共库建议保持纯 JVM API 或提供独立 DEX 打包。</li></ul></li><li><strong>性能调优</strong><ul><li>JVM：关注 GC 调参、JIT 配置、JFR 诊断；</li><li>ART：关注冷启动优化、Profile Guided Optimization（PGO）、减少反射调用与动态代理。</li></ul></li></ul><h2 id="_10-总结与趋势" tabindex="-1">10. 总结与趋势 <a class="header-anchor" href="#_10-总结与趋势" aria-label="Permalink to “10. 总结与趋势”">​</a></h2><ul><li>JVM 与 ART 的差异根本在于目标场景不同：前者追求跨平台和高吞吐，后者强调端侧体验与能效。</li><li>ART 正在从纯 AOT 转向混合编译，吸收 JVM 在 JIT 领域的经验，同时结合端侧特性（如 Baseline Profiles、Cloud Profiles）。</li><li>JVM 生态则持续完善即时编译与 GC 创新，为云端高密度部署服务。</li><li>对开发者而言，应理解两者在包管理、调试、性能调优上的差异，针对场景选择对应的工具链与优化策略。</li></ul><blockquote><p>建议：在团队培训或文档中，将 JVM/ART 对比与实际问题（如冷启动优化、包体积控制、Native 互调）结合，形成可复制的诊断手册。</p></blockquote>',22)])])}const T=i(r,[["render",o]]);export{A as __pageData,T as default};
