import{_ as e,c as s,o as a,al as n}from"./chunks/framework.GtCa91sV.js";const k=JSON.parse('{"title":"Glide 原理与源码解读","description":"","frontmatter":{},"headers":[],"relativePath":"android/主流库原理/Glide原理.md","filePath":"android/主流库原理/Glide原理.md","lastUpdated":1764061109000}'),l={name:"android/主流库原理/Glide原理.md"};function t(r,i,d,o,h,c){return a(),s("div",null,[...i[0]||(i[0]=[n(`<h1 id="glide-原理与源码解读" tabindex="-1">Glide 原理与源码解读 <a class="header-anchor" href="#glide-原理与源码解读" aria-label="Permalink to “Glide 原理与源码解读”">​</a></h1><h2 id="核心概述" tabindex="-1">核心概述 <a class="header-anchor" href="#核心概述" aria-label="Permalink to “核心概述”">​</a></h2><p>Glide 是 Google 推出的 Android 图片加载库，整合解码、缓存、变换与生命周期管理，强调流畅性与资源复用。其设计核心在于多级缓存、自动化生命周期绑定与灵活的请求流水线。</p><h2 id="模块与架构" tabindex="-1">模块与架构 <a class="header-anchor" href="#模块与架构" aria-label="Permalink to “模块与架构”">​</a></h2><ul><li><strong>RequestManager / RequestBuilder</strong>：负责创建与管理图片请求，自动感知 <code>Activity</code>/<code>Fragment</code> 生命周期。</li><li><strong>Engine</strong>：调度解码、缓存、资源复用的核心引擎。</li><li><strong>缓存体系</strong>：分为活动资源缓存（<code>ActiveResources</code>）、内存缓存（<code>LruResourceCache</code>）、磁盘缓存（<code>DiskLruCacheWrapper</code>）。</li><li><strong>线程池</strong>：<code>GlideExecutor</code> 根据任务类型（磁盘/源/动画）分配不同的线程池。</li><li><strong>解码管线</strong>：<code>DecodeJob</code> 串联数据加载、解码、变换、编码。</li></ul><h2 id="加载流程拆解" tabindex="-1">加载流程拆解 <a class="header-anchor" href="#加载流程拆解" aria-label="Permalink to “加载流程拆解”">​</a></h2><ol><li><code>Glide.with(context)</code> 返回 <code>RequestManager</code>，绑定生命周期。</li><li><code>load(url).into(imageView)</code> 创建 <code>RequestBuilder</code>，最终生成 <code>SingleRequest</code>。</li><li><code>RequestManager</code> 将请求交给 <code>Engine</code>，尝试命中活动资源或内存缓存。</li><li>未命中时启动 <code>EngineJob</code>，提交到线程池执行 <code>DecodeJob</code>。</li><li><code>DecodeJob</code> 先查磁盘缓存，若仍未命中则通过 <code>ModelLoader</code> 拉取源数据并解码。</li><li>解码结果经过变换（Transform）后，缓存并回调主线程更新 UI。</li></ol><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 简化后的请求发起流程，展示 Engine 的缓存命中策略</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadFromEngine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EngineKey</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, width: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, height: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Resource</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;*&gt;? {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 活动资源缓存，避免重复加载同一资源</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    activeResources[key]?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 内存缓存命中后会转入活动资源管理</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    memoryCache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key)?.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { activeResources.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">activate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key, it); </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> it }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 未命中则需要启动解码任务</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="关键源码细节" tabindex="-1">关键源码细节 <a class="header-anchor" href="#关键源码细节" aria-label="Permalink to “关键源码细节”">​</a></h2><ul><li><strong>生命周期感知</strong>：<code>SupportRequestManagerFragment</code> 隐藏附着在 FragmentManager 中，自动处理 <code>onStart</code>/<code>onStop</code>/<code>onDestroy</code>，避免内存泄漏。</li><li><strong>多级缓存协同</strong>：活动资源使用 <code>ReferenceQueue</code> + 弱引用追踪，内存缓存按 LRU 淘汰，磁盘缓存默认 250MB 可调。</li><li><strong>ModelLoader</strong>：通过注册表（<code>Registry</code>）将模型类型（URL、Uri、File 等）映射到数据加载器，便于扩展。</li><li><strong>变换链</strong>：<code>Transformation</code> 支持链式组合，最终在 <code>ResourceEncoder</code> 写回磁盘缓存。</li></ul><h2 id="实践与扩展建议" tabindex="-1">实践与扩展建议 <a class="header-anchor" href="#实践与扩展建议" aria-label="Permalink to “实践与扩展建议”">​</a></h2><ul><li>自定义 <code>ModelLoader</code> 支持特殊协议或加密图源。</li><li>通过 <code>DiskCacheStrategy</code> 精细控制磁盘缓存策略（ALL、RESOURCE、DATA、NONE）。</li><li>在 <code>RequestOptions</code> 中统一设置占位图、错误图、裁剪/变换策略。</li><li>使用 <code>AppGlideModule</code> 注册全局配置、日志、解码器或内存缓存大小。</li></ul><h2 id="风险与优化" tabindex="-1">风险与优化 <a class="header-anchor" href="#风险与优化" aria-label="Permalink to “风险与优化”">​</a></h2><ul><li><strong>内存压力</strong>：大图加载需关注 <code>DownsampleStrategy</code> 与 <code>PreferredBitmapConfig</code>，避免 OOM。</li><li><strong>生命周期错位</strong>：确保在非 UI 场景使用 <code>ApplicationContext</code>，防止泄漏。</li><li><strong>线程调度</strong>：IO 密集任务宜划分线程池优先级，避免与业务线程互抢。</li></ul><h2 id="调试建议" tabindex="-1">调试建议 <a class="header-anchor" href="#调试建议" aria-label="Permalink to “调试建议”">​</a></h2><ul><li>启用 <code>setLogLevel(Log.VERBOSE)</code> 查看内部日志。</li><li>借助 <code>GlideTrace</code>（自 AndroidX Start 版本）分析主线程阻塞。</li><li>使用 <code>GlideApp</code> + Debug 工具查看缓存命中率与内存占用。</li></ul>`,16)])])}const g=e(l,[["render",t]]);export{k as __pageData,g as default};
