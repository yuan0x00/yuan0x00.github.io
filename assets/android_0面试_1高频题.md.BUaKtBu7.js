import{_ as i,c as e,o as a,al as n}from"./chunks/framework.BS8slTKV.js";const h=JSON.parse('{"title":"高频题","description":"","frontmatter":{},"headers":[],"relativePath":"android/0面试/1高频题.md","filePath":"android/0面试/1高频题.md","lastUpdated":1763101199000}'),s={name:"android/0面试/1高频题.md"};function o(p,l,d,c,r,t){return a(),e("div",null,[...l[0]||(l[0]=[n(`<h1 id="高频题" tabindex="-1">高频题 <a class="header-anchor" href="#高频题" aria-label="Permalink to “高频题”">​</a></h1><h2 id="java" tabindex="-1">Java <a class="header-anchor" href="#java" aria-label="Permalink to “Java”">​</a></h2><ul><li>List和ArrayList区别、原理、扩容 <ul><li><code>List是接口，ArrayList是其实现类。ArrayList使用动态数组的数据结构。add时会检查扩容，get时会根据索引查找。</code></li><li><code>java8扩容时会创建旧容量1.5倍的数组复制过去，java17会检查最小增长量和1.5中最大的，一步到位。</code></li></ul></li><li>HashMap、LinkedHashMap、ConcurrentHashMap区别、原理、扩容 <ul><li><code>HashMap数组 + 链表/红黑树。LinkedHashMap数组 + 链表/红黑树 + 双向链表。ConcurrentHashMap数组 + 链表/红黑树。</code></li><li><code>HashMap容量超过容量 × 负载因子时扩容，容量翻倍（2的幂次），利用 (hash &amp; oldCapacity) == 0 判断，将链表拆分成两个，减少重新计算。</code></li></ul></li><li>线程池创建方式、原理 <ul><li><code>ThreadPoolExecutor:核心线程数、最大线程数、空闲线程存活时间、时间单位、工作队列、线程工厂、拒绝策略</code></li><li><code>Executors工厂方法：</code><ul><li><code>Executors.newFixedThreadPool、</code></li><li><code>Executors.newCachedThreadPool、</code></li><li><code>Executors.newSingleThreadExecutor、</code></li><li><code>Executors.newSingleThreadExecutor</code></li></ul></li><li><code>自定义线程工厂</code></li><li><code>ScheduledThreadPoolExecutor</code></li><li><code>JDK21虚拟线程</code></li></ul></li><li>安卓中锁的种类、使用 <ul><li><code>volatile</code></li><li><code>synchronized</code></li><li><code>ReentrantLock</code></li><li><code>Atomic类</code></li><li><code>Handler</code></li></ul></li><li>重载里可以使用泛型吗？泛型擦除了解吗？ <ul><li><code>重载可以使用泛型，但是需要参数列表个数不一样。泛型擦除是为了兼容旧版本没有泛型而设计的，在运行时会将泛型擦除为Object或第一个泛型上界。泛型是编译期类型安全检查。</code></li><li><code>需要读取数据时 → 使用 ? extends T（上界）</code></li><li><code>需要写入数据时 → 使用 ? super T（下界）</code></li><li><code>既读又写时 → 不要使用通配符，直接用 &lt;T&gt;</code></li></ul></li><li>final关键字有什么作用？ <ul><li><code>修饰类禁止继承。修饰方法禁止重写。修饰变量禁止重新赋值（引用类型是禁止改变引用）。保证线程安全 - 安全发布不可变对象。</code></li></ul></li><li>深拷贝和浅拷贝 <ul><li><code>深拷贝和浅拷贝是对象复制的两种不同方式，主要区别在于对引用类型字段的处理。复制对象本身，深拷贝同时递归复制对象内部所有引用类型字段指向的对象</code></li></ul></li><li>实现线程安全的方法有哪些？ <ul><li><code>不可变对象：</code></li><li><code>同步机制：volatile、synchronized、ReentrantLock、并发集合类、不可变集合、原子变量类、ThreadLocal、读写锁、StampedLock。</code></li></ul></li><li>sleep和wait有什么区别？ <ul><li><code>sleep是Thread类的静态方法。wait是Object类的方法。sleep不会释放锁。wait需要释放锁，需要手动唤醒。</code></li></ul></li></ul><h2 id="jvm" tabindex="-1">JVM <a class="header-anchor" href="#jvm" aria-label="Permalink to “JVM”">​</a></h2><ul><li>GC流程 <ul><li><code>GC主要分三步：</code></li><li><code>标记：从GC Roots（如线程栈、静态变量）出发，标记所有存活对象。</code></li><li><code>清理：回收未被标记的垃圾对象内存。</code></li><li><code>整理（可选）：移动存活对象，消除内存碎片。</code></li><li><code>关键算法：新生代用&quot;复制&quot;，老年代用&quot;标记-整理&quot;或&quot;标记-清除&quot;。</code></li></ul></li></ul><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span>新对象 → Eden区</span></span>
<span class="line"><span>↓</span></span>
<span class="line"><span>Eden满 → Minor GC</span></span>
<span class="line"><span>↓</span></span>
<span class="line"><span>存活对象 → Survivor区 (反复复制)</span></span>
<span class="line"><span>↓</span></span>
<span class="line"><span>存活达阈值 → 晋升老年代</span></span>
<span class="line"><span>↓  </span></span>
<span class="line"><span>老年代满 → Full GC (全局回收)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="android" tabindex="-1">Android <a class="header-anchor" href="#android" aria-label="Permalink to “Android”">​</a></h2><ul><li><p>设计模式：MVC、MVP、MVVM、MVI、模块化、组件化、</p></li><li><p>App启动流程</p></li><li><p>Activity生命周期、保存机制、启动模式、任务栈</p></li><li><p>自定义View</p></li><li><p>onMeasure会传递两个参数，会用到这两个参数做什么事情？</p></li><li><p>onLayout摆放的逻辑是什么，参数怎么用的？</p></li><li><p>事件分发机制、滑动冲突</p></li><li><p>Handler机制</p></li><li><p>线程间通信机制</p></li><li><p>进程间通信机制</p></li><li><p>OkHttp原理、Retrofit原理、Glide原理、Bugly原理、Lifecycle原理、ViewModel原理、RecyclerView原理</p></li><li><p>Crash、ANR捕获、检测</p></li><li><p>常用设计模式：工厂模式、建造者模式、单例模式、都解决什么问题的</p></li><li><p>内存泄露</p></li><li><p>性能优化：内存优化、启动优化、卡顿优化、编译优化、包优化</p></li><li><p>SparseArray 和 ArrayMap了解吗</p></li><li><p>一个图片的内存是怎么计算的？</p></li><li><p>约束布局有什么缺点？</p></li><li><p>mmkv比sp有什么优势？</p></li><li><p>Android 中如何实现屏幕适配?</p></li><li><p>如何判断当前线程是不是主线程？</p></li><li><p>如何优化 RecyclerView 的性能？</p></li><li><p>如何处理 WebView 的内存泄漏？</p></li><li><p>安卓是怎么加载代码的？</p></li><li><p>用ViewGroup去实现纵向的列表?</p></li><li><p>OOM有那几种异常类型?</p></li><li><p>Java 中 Object 的 clone()方法如何实现深拷贝？描述其步骤并实现。</p></li><li><p>怎么做的应用质量保障？开发阶段？测试阶段？上线之后？</p></li><li><p>流畅度的评价指标是什么？</p></li><li><p>如何检测应用性能好不好？</p></li><li><p>kotlin切换线程和Java切换线程有什么区别？</p></li></ul><h3 id="kotlin" tabindex="-1">Kotlin <a class="header-anchor" href="#kotlin" aria-label="Permalink to “Kotlin”">​</a></h3><ul><li>作用域函数let、run、also、apply、with</li><li>类委托、属性委托</li><li>扩展函数、扩展函数的局限性</li><li>集合、可变集合</li><li>主要构造函数、次要构造函数</li><li>伴生对象</li><li>为什么协程开销更小</li><li>协程中如何捕获异常？父子协程如何捕获异常？</li><li>一个父协程里有两个子协程，父协程取消了，子协程会取消吗？</li><li>一个协程里做了循环的io操作，协程取消了，io操作会取消吗？</li><li>为什么使用协程，开发中有什么便利点？</li><li>flow原理，协程能做的东西，flow也能做，为什么要有flow?</li></ul><h3 id="compose" tabindex="-1">Compose <a class="header-anchor" href="#compose" aria-label="Permalink to “Compose”">​</a></h3><ul><li>remember 、mutableStateOf、rememberSaveable</li><li>重组是什么、原理</li><li>LaunchedEffect、SideEffect</li></ul>`,12)])])}const b=i(s,[["render",o]]);export{h as __pageData,b as default};
