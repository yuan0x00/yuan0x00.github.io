import{_ as i,c as s,o as a,aj as l}from"./chunks/framework.BiF827kf.js";const k=JSON.parse('{"title":"RecyclerView 原理与源码解读","description":"","frontmatter":{},"headers":[],"relativePath":"android/3主流库源码/Jetpack/RecyclerView原理源码.md","filePath":"android/3主流库源码/Jetpack/RecyclerView原理源码.md","lastUpdated":1762951275000}'),n={name:"android/3主流库源码/Jetpack/RecyclerView原理源码.md"};function t(r,e,o,d,c,h){return a(),s("div",null,[...e[0]||(e[0]=[l(`<h1 id="recyclerview-原理与源码解读" tabindex="-1">RecyclerView 原理与源码解读 <a class="header-anchor" href="#recyclerview-原理与源码解读" aria-label="Permalink to “RecyclerView 原理与源码解读”">​</a></h1><h2 id="核心概述" tabindex="-1">核心概述 <a class="header-anchor" href="#核心概述" aria-label="Permalink to “核心概述”">​</a></h2><p>RecyclerView 是高度可扩展的列表容器，通过 ViewHolder 缓存、可插拔的 LayoutManager、ItemDecoration 与动画系统，实现高性能的列表与网格展示。其关键在于回收复用机制、增量绘制与差分更新。</p><h2 id="架构组成" tabindex="-1">架构组成 <a class="header-anchor" href="#架构组成" aria-label="Permalink to “架构组成”">​</a></h2><ul><li><strong>Adapter</strong>：负责创建与绑定 ViewHolder，提供数据源。</li><li><strong>ViewHolder</strong>：缓存 item 内部视图引用，避免重复查找。</li><li><strong>LayoutManager</strong>：决定布局方式（Linear/Grid/Staggered 等），负责测量、定位与回收逻辑。</li><li><strong>Recycler</strong>：管理 <code>RecycledViewPool</code> 与临时缓存（<code>ViewCacheExtension</code>），为 LayoutManager 提供可复用 ViewHolder。</li><li><strong>ItemAnimator</strong>：处理增删改动画。</li><li><strong>DiffUtil/ListAdapter</strong>：辅助差分刷新，提高效率。</li></ul><h2 id="布局与滑动流程" tabindex="-1">布局与滑动流程 <a class="header-anchor" href="#布局与滑动流程" aria-label="Permalink to “布局与滑动流程”">​</a></h2><ol><li>初始化阶段调用 <code>setLayoutManager</code>、<code>setAdapter</code>，RecyclerView 注册数据观察者。</li><li>布局时进入 <code>dispatchLayout</code>，依次处理 <code>onLayoutChildren</code>（由 LayoutManager 实现），期间通过 <code>Recycler.getViewForPosition</code> 获取复用 View。</li><li>滑动阶段 <code>scrollBy</code> -&gt; <code>LayoutManager.scrollHorizontallyBy/scrollVerticallyBy</code>，在移动中回收离屏 View 并填充新 View。</li><li>Adapter 数据变更时，<code>notifyItemChanged</code> 等方法触发 <code>AdapterHelper</code> 记录操作，下一帧 <code>dispatchLayoutStep1/2/3</code> 执行动画与更新。</li></ol><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Recycler 获取复用 View 的关键逻辑</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getViewForPosition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(position: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">): </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">View</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> holder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> tryGetViewHolderForPositionByDeadline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(position)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (holder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        holder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mAdapter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createViewHolder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mAdapter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getItemViewType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(position))</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    mAdapter.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bindViewHolder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(holder, position)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> holder.itemView</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="关键源码细节" tabindex="-1">关键源码细节 <a class="header-anchor" href="#关键源码细节" aria-label="Permalink to “关键源码细节”">​</a></h2><ul><li><strong>缓存层级</strong>：<code>Recycler</code> 维护双层缓存（<code>mAttachedScrap</code>、<code>mCachedViews</code>），更远层次使用 <code>RecycledViewPool</code> 共享跨 RecyclerView 的 ViewHolder。</li><li><strong>预取（Prefetch）</strong>：<code>GapWorker</code> 在滑动预测下一个位置时提前创建/绑定 View，改善滑动流畅度。</li><li><strong>StableIds</strong>：启用 <code>setHasStableIds(true)</code>，结合 DiffUtil 提高动画精度。</li><li><strong>ItemTouchHelper</strong>：基于 RecyclerView 扩展，提供拖拽/滑动删除等交互。</li></ul><h2 id="实践建议" tabindex="-1">实践建议 <a class="header-anchor" href="#实践建议" aria-label="Permalink to “实践建议”">​</a></h2><ul><li>使用 <code>ListAdapter</code> 或 <code>AsyncListDiffer</code> 自动处理差分更新，避免手动 <code>notifyDataSetChanged</code>。</li><li>对大列表启用 <code>setItemViewCacheSize</code>、<code>setRecycledViewPool</code> 优化复用。</li><li>将耗时操作放在 <code>onBindViewHolder</code> 外部，避免 UI 卡顿；图片加载结合 Glide/Fresco。</li><li>结合 <code>ConcatAdapter</code> 实现多类型拼接，避免复杂的 switch 逻辑。</li></ul><h2 id="风险与调试" tabindex="-1">风险与调试 <a class="header-anchor" href="#风险与调试" aria-label="Permalink to “风险与调试”">​</a></h2><ul><li><strong>内存泄漏</strong>：ViewHolder 持有外部引用需谨慎；在 <code>onViewRecycled</code> 中释放资源。</li><li><strong>滑动性能</strong>：使用 Android Profiler 分析掉帧，检查 <code>GapWorker</code> 预取是否生效。</li><li>调试布局可调用 <code>RecyclerView.setItemViewCacheSize(0)</code> 观察回收行为，或启用 <code>LinearLayoutManager.setStackFromEnd</code> 验证边缘对齐。</li></ul>`,14)])])}const g=i(n,[["render",t]]);export{k as __pageData,g as default};
