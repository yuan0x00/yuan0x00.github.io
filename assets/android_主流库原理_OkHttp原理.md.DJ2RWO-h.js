import{_ as i,c as e,o as a,al as n}from"./chunks/framework.GtCa91sV.js";const k=JSON.parse('{"title":"OkHttp 原理与源码解读","description":"","frontmatter":{},"headers":[],"relativePath":"android/主流库原理/OkHttp原理.md","filePath":"android/主流库原理/OkHttp原理.md","lastUpdated":1764061109000}'),t={name:"android/主流库原理/OkHttp原理.md"};function l(r,s,o,h,p,d){return a(),e("div",null,[...s[0]||(s[0]=[n(`<h1 id="okhttp-原理与源码解读" tabindex="-1">OkHttp 原理与源码解读 <a class="header-anchor" href="#okhttp-原理与源码解读" aria-label="Permalink to “OkHttp 原理与源码解读”">​</a></h1><h2 id="核心概述" tabindex="-1">核心概述 <a class="header-anchor" href="#核心概述" aria-label="Permalink to “核心概述”">​</a></h2><p>OkHttp 是 Square 开源的高性能 HTTP 客户端，提供连接池、透明压缩、缓存与 WebSocket 支持。其设计重点在于通过拦截器链与连接复用实现稳定且高效的网络通信。</p><h2 id="模块与架构" tabindex="-1">模块与架构 <a class="header-anchor" href="#模块与架构" aria-label="Permalink to “模块与架构”">​</a></h2><ul><li><strong>拦截器链</strong>：<code>RealInterceptorChain</code> 串联用户、重试、桥接、缓存、连接、网络拦截器等节点。</li><li><strong>连接管理</strong>：<code>ConnectionPool</code> 维护持久连接，结合 HTTP/2 多路复用降低握手成本。</li><li><strong>调度中心</strong>：<code>Dispatcher</code> 管理同步/异步请求队列与线程池。</li><li><strong>缓存体系</strong>：支持内存 + 磁盘缓存，标准遵循 RFC 7234。</li><li><strong>事件监听</strong>：<code>EventListener</code> 提供关键阶段回调，便于埋点与调试。</li></ul><h2 id="请求执行流程" tabindex="-1">请求执行流程 <a class="header-anchor" href="#请求执行流程" aria-label="Permalink to “请求执行流程”">​</a></h2><ol><li>构建 <code>OkHttpClient</code> 并调用 <code>newCall(request)</code> 返回 <code>RealCall</code>。</li><li><code>RealCall.enqueue</code> 提交到 <code>Dispatcher</code> 线程池；<code>execute</code> 则阻塞当前线程。</li><li><code>RealCall</code> 通过 <code>RealInterceptorChain.proceed</code> 触发拦截器依次执行。</li><li><code>ConnectInterceptor</code> 负责从连接池获取或新建 <code>RealConnection</code>。</li><li><code>CallServerInterceptor</code> 最终与服务器读写数据，得到 <code>Response</code>。</li></ol><div class="language-java line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 拦截器链核心片段，展示链式调用流程</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Response </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">proceed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Request request, StreamAllocation allocation, HttpCodec codec, RealConnection connection) throws IOException {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interceptors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">throw</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> AssertionError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    RealInterceptorChain next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> RealInterceptorChain</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(interceptors, streamAllocation, httpCodec, connection, index </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, request);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Interceptor interceptor </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interceptors.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(index);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 每个拦截器负责处理自身逻辑，并调用 next.proceed 进入下一个</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Response response </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interceptor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">intercept</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(next);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="关键源码细节" tabindex="-1">关键源码细节 <a class="header-anchor" href="#关键源码细节" aria-label="Permalink to “关键源码细节”">​</a></h2><ul><li><strong>连接池</strong>：默认最大闲置连接 5 条、保持 5 分钟，可通过 <code>ConnectionPool</code> 自定义；利用 <code>cleanupRunnable</code> 定时回收。</li><li><strong>HTTP/2</strong>：<code>RealConnection</code> 在握手后构建 <code>Http2Connection</code>，通过 Stream 分发请求，多路复用减轻阻塞。</li><li><strong>超时控制</strong>：<code>OkHttpClient</code> 对连接、读、写分别提供超时；<code>CallTimeoutInterceptor</code> 保障整体耗时边界。</li><li><strong>缓存实现</strong>：<code>Cache</code> 基于 <code>DiskLruCache</code>，遵循响应头策略；通过 <code>CacheStrategy</code> 决定命中、条件请求或回源。</li></ul><h2 id="常见扩展" tabindex="-1">常见扩展 <a class="header-anchor" href="#常见扩展" aria-label="Permalink to “常见扩展”">​</a></h2><ul><li>自定义拦截器实现统一 Header、签名、限流或离线缓存策略。</li><li>通过 <code>EventListener.Factory</code> 采集 DNS、连接、请求、响应等阶段耗时。</li><li>配合 <code>MockWebServer</code> 进行集成测试，验证弱网重试与缓存控制。</li></ul><h2 id="风险与优化建议" tabindex="-1">风险与优化建议 <a class="header-anchor" href="#风险与优化建议" aria-label="Permalink to “风险与优化建议”">​</a></h2><ul><li><strong>资源释放</strong>：确保 <code>ResponseBody</code> 在使用后关闭，否则连接无法回收。</li><li><strong>线程安全</strong>：拦截器需无状态或自行同步；避免在拦截器中执行耗时阻塞操作。</li><li><strong>证书管理</strong>：HTTPS 场景下关注证书锁定（Pinning）与自签证书信任链配置。</li></ul><h2 id="调试方法" tabindex="-1">调试方法 <a class="header-anchor" href="#调试方法" aria-label="Permalink to “调试方法”">​</a></h2><ul><li>启用 <code>HttpLoggingInterceptor</code> 或 <code>EventListener</code> 输出详细日志。</li><li>使用 <code>setProxy</code> + Charles/Fiddler 进行抓包分析。</li><li>结合 <code>StrictMode</code> 检测主线程网络调用，保障响应性。</li></ul>`,16)])])}const g=i(t,[["render",l]]);export{k as __pageData,g as default};
