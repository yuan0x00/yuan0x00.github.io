import{_ as i,c as e,o as a,aj as n}from"./chunks/framework.BiF827kf.js";const o=JSON.parse('{"title":"Lifecycle 原理与源码解读","description":"","frontmatter":{},"headers":[],"relativePath":"android/2主流库源码/Jetpack/Lifecycle原理源码.md","filePath":"android/2主流库源码/Jetpack/Lifecycle原理源码.md","lastUpdated":1762951116000}'),l={name:"android/2主流库源码/Jetpack/Lifecycle原理源码.md"};function t(r,s,c,p,h,k){return a(),e("div",null,[...s[0]||(s[0]=[n(`<h1 id="lifecycle-原理与源码解读" tabindex="-1">Lifecycle 原理与源码解读 <a class="header-anchor" href="#lifecycle-原理与源码解读" aria-label="Permalink to “Lifecycle 原理与源码解读”">​</a></h1><h2 id="核心概述" tabindex="-1">核心概述 <a class="header-anchor" href="#核心概述" aria-label="Permalink to “核心概述”">​</a></h2><p>Lifecycle 是 Jetpack 架构组件之一，为组件化生命周期感知提供统一抽象。通过 <code>LifecycleOwner</code> 暴露生命周期状态，<code>LifecycleObserver</code> 实现事件监听，底层由 <code>LifecycleRegistry</code> 维护状态机并驱动回调，实现 UI 组件与业务逻辑解耦。</p><h2 id="架构组成" tabindex="-1">架构组成 <a class="header-anchor" href="#架构组成" aria-label="Permalink to “架构组成”">​</a></h2><ul><li><strong>LifecycleOwner</strong>：如 <code>ComponentActivity</code>、<code>Fragment</code>，实现 <code>getLifecycle()</code> 暴露生命周期。</li><li><strong>LifecycleRegistry</strong>：具体状态机实现，负责状态同步与事件分发。</li><li><strong>LifecycleObserver / DefaultLifecycleObserver</strong>：观察者接口，支持注解式与接口式回调。</li><li><strong>ReportFragment</strong>：旧版通过隐藏 Fragment 监听 Activity 生命周期；AndroidX 中已由 <code>LifecycleDispatcher</code> 统一处理。</li><li><strong>ProcessLifecycleOwner</strong>：全局生命周期提供者，基于 <code>Application</code> + <code>ActivityLifecycleCallbacks</code> 实现前后台感知。</li></ul><h2 id="状态迁移流程" tabindex="-1">状态迁移流程 <a class="header-anchor" href="#状态迁移流程" aria-label="Permalink to “状态迁移流程”">​</a></h2><ol><li>Activity/Fragment 生命周期事件触发时调用 <code>LifecycleRegistry.handleLifecycleEvent(event)</code>。</li><li><code>handleLifecycleEvent</code> 将事件映射为目标状态（如 ON_START -&gt; STARTED），并调用 <code>moveToState</code>。</li><li><code>moveToState</code> 遍历观察者，这里维护了两套数据结构：<code>observerMap</code>（按插入顺序）和 <code>statefulObserverMap</code>（按状态排序），确保状态逐级推进。</li><li>当状态提升时，依次回调 <code>onCreate</code>、<code>onStart</code>、<code>onResume</code>；降级时反向回调，保证事件顺序一致。</li></ol><div class="language-kotlin line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">kotlin</span><pre class="shiki shiki-themes github-light github-dark" style="--shiki-light:#24292e;--shiki-dark:#e1e4e8;--shiki-light-bg:#fff;--shiki-dark-bg:#24292e;" tabindex="0" dir="ltr"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// LifecycleRegistry 核心状态机逻辑摘录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleLifecycleEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    val</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nextState </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getStateAfter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    moveToState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nextState)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> moveToState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(next: </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">State</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    state </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> next</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (handlingEvent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> addingObserverCounter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) { newEventOccurred </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 向上推进状态</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    sync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">private</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fun</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">isSynced</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        forwardPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态提升</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        backwardPass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 状态回退</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><h2 id="关键源码细节" tabindex="-1">关键源码细节 <a class="header-anchor" href="#关键源码细节" aria-label="Permalink to “关键源码细节”">​</a></h2><ul><li><strong>ObserverWithState</strong>：包装观察者并记录当前状态，避免重复回调。</li><li><strong>State 优先级</strong>：<code>State.CREATED &lt; STARTED &lt; RESUMED</code>，保证状态线性推进。</li><li><strong>线程安全策略</strong>：<code>LifecycleRegistry</code> 大量使用 <code>SafeIterableMap</code> 保证在遍历时动态添加/移除观察者不会 ConcurrentModification。</li><li><strong>反射兼容</strong>：旧版 <code>LifecycleObserver</code> 通过注解 + 反射调用，推荐使用 <code>DefaultLifecycleObserver</code> 减少性能开销。</li></ul><h2 id="实践建议" tabindex="-1">实践建议 <a class="header-anchor" href="#实践建议" aria-label="Permalink to “实践建议”">​</a></h2><ul><li>尽量依赖 <code>LifecycleOwner</code> 注入，避免手动管理生命周期引用。</li><li>对异步任务使用 <code>LifecycleScope</code> 或 <code>repeatOnLifecycle</code> 函数，自动在特定状态下启动/取消协程。</li><li>在自定义控件中实现 <code>LifecycleOwner</code>，结合 <code>LifecycleRegistry</code> 感知附着与分离事件。</li></ul><h2 id="风险与调试" tabindex="-1">风险与调试 <a class="header-anchor" href="#风险与调试" aria-label="Permalink to “风险与调试”">​</a></h2><ul><li><strong>状态不一致</strong>：嵌套 Fragment 若手动调用生命周期方法易导致状态漂移，建议使用官方 FragmentManager 管理。</li><li><strong>泄漏风险</strong>：长时任务需在 <code>ON_STOP</code> 或 <code>ON_DESTROY</code> 中释放，或使用协程/Flow 自动取消。</li><li>调试可开启 <code>setDebug(true)</code>（需自定义扩展），或在 <code>LifecycleEventObserver</code> 中打印状态流转。</li></ul>`,14)])])}const E=i(l,[["render",t]]);export{o as __pageData,E as default};
