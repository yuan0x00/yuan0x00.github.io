import{_ as a,c as o,o as i,al as d}from"./chunks/framework.BS8slTKV.js";const g=JSON.parse('{"title":"Fragment 详解","description":"","frontmatter":{},"headers":[],"relativePath":"android/2组件与机制/应用组件/Fragment详解.md","filePath":"android/2组件与机制/应用组件/Fragment详解.md","lastUpdated":1762951275000}'),l={name:"android/2组件与机制/应用组件/Fragment详解.md"};function t(n,e,c,r,m,s){return i(),o("div",null,[...e[0]||(e[0]=[d('<h1 id="fragment-详解" tabindex="-1">Fragment 详解 <a class="header-anchor" href="#fragment-详解" aria-label="Permalink to “Fragment 详解”">​</a></h1><p>Fragment 是可复用的界面与逻辑单元，可在 Activity 中动态组合 UI。借助 Fragment，可实现自适应布局、模块化导航与更细粒度的生命周期管理。</p><h2 id="角色定位与使用价值" tabindex="-1">角色定位与使用价值 <a class="header-anchor" href="#角色定位与使用价值" aria-label="Permalink to “角色定位与使用价值”">​</a></h2><ul><li>在单 Activity 架构中承载不同页面或流程步骤。</li><li>支持手机、平板、折叠屏的多栏布局与响应式设计。</li><li>与 ViewModel、Navigation 组件配合，实现状态分离与无缝路由。</li></ul><h2 id="生命周期与宿主协作" tabindex="-1">生命周期与宿主协作 <a class="header-anchor" href="#生命周期与宿主协作" aria-label="Permalink to “生命周期与宿主协作”">​</a></h2><ul><li><code>onAttach()</code>：获取 <code>Context</code> 与生命周期回调，可注入依赖。</li><li><code>onCreate()</code>：初始化不可见的状态数据，如 ViewModel、Adapter。</li><li><code>onCreateView()</code> / <code>onViewCreated()</code>：加载布局并绑定视图；建议在 <code>onViewCreated()</code> 中完成 View 绑定。</li><li><code>onStart()</code> / <code>onResume()</code>：界面可见/可交互，订阅数据源。</li><li><code>onPause()</code> / <code>onStop()</code>：暂停动画、释放摄像头等重资源。</li><li><code>onDestroyView()</code>：销毁视图层级，清理与 View 相关的引用，避免内存泄漏。</li><li><code>onDestroy()</code> / <code>onDetach()</code>：销毁剩余资源并与宿主分离。</li></ul><blockquote><p>关键提示：ViewBinding 等引用需在 <code>onDestroyView()</code> 重置为 null，以免泄漏。</p></blockquote><h2 id="fragmentmanager-与事务管理" tabindex="-1">FragmentManager 与事务管理 <a class="header-anchor" href="#fragmentmanager-与事务管理" aria-label="Permalink to “FragmentManager 与事务管理”">​</a></h2><ul><li>通过 <code>FragmentManager</code> 的 <code>beginTransaction()</code> 发起事务，支持 <code>add</code>、<code>replace</code>、<code>remove</code>、<code>show</code>、<code>hide</code>。</li><li>使用 <code>addToBackStack()</code> 控制返回栈；对于多模块路由，推荐统一封装导航器。</li><li>避免在 <code>commit()</code> 后立即访问视图，可使用 <code>commitNow()</code> 或 <code>executePendingTransactions()</code> 确保同步完成。</li></ul><h2 id="navigation-component-集成" tabindex="-1">Navigation Component 集成 <a class="header-anchor" href="#navigation-component-集成" aria-label="Permalink to “Navigation Component 集成”">​</a></h2><ul><li>使用 <code>NavHostFragment</code> 承载导航图，简化事务管理。</li><li>Safe Args 插件生成类型安全的参数传递类。</li><li>支持深层链接（Deep Link）与全局动作（Global Action），提升可维护性。</li></ul><h2 id="状态与通信" tabindex="-1">状态与通信 <a class="header-anchor" href="#状态与通信" aria-label="Permalink to “状态与通信”">​</a></h2><ul><li>Fragment 共享状态：使用 <code>ViewModelProvider(requireActivity())</code> 获得 Activity 级 ViewModel。</li><li>结果回传：采用 <code>FragmentResultListener</code> 替代旧版 <code>setTargetFragment()</code>。</li><li>与 Activity 通信：定义接口或使用共享 ViewModel，避免直接强转。</li></ul><h2 id="多窗口与自适应布局" tabindex="-1">多窗口与自适应布局 <a class="header-anchor" href="#多窗口与自适应布局" aria-label="Permalink to “多窗口与自适应布局”">​</a></h2><ul><li>借助 <code>FragmentContainerView</code> 与 <code>childFragmentManager</code> 构建嵌套布局。</li><li>使用 <code>FragmentTransaction#setReorderingAllowed(true)</code> 减少状态丢失。</li><li>针对横屏/大屏场景，结合 <code>SlidingPaneLayout</code>、<code>Jetpack WindowManager</code> 动态调整布局。</li></ul><h2 id="compose-与-fragment-的协作" tabindex="-1">Compose 与 Fragment 的协作 <a class="header-anchor" href="#compose-与-fragment-的协作" aria-label="Permalink to “Compose 与 Fragment 的协作”">​</a></h2><ul><li>在 Fragment 中使用 <code>ComposeView</code> 嵌入 Compose UI，调用 <code>setViewCompositionStrategy</code> 指定销毁策略。</li><li>Activity + Compose 导航中，可使用 <code>AndroidViewBinding</code>/<code>AndroidView</code> 承载传统 View。</li></ul><h2 id="性能与稳定性" tabindex="-1">性能与稳定性 <a class="header-anchor" href="#性能与稳定性" aria-label="Permalink to “性能与稳定性”">​</a></h2><ul><li>避免在 Fragment 构造函数中传参，统一使用 <code>arguments</code> Bundle。</li><li>处理重建：使用 <code>setRetainInstance(false)</code>（默认）并依赖 ViewModel；若需保留，考虑 <code>FragmentFactory</code>。</li><li>事务过多导致状态丢失：检查 <code>commitAllowingStateLoss()</code> 的使用，尽量避免。</li></ul><h2 id="测试策略" tabindex="-1">测试策略 <a class="header-anchor" href="#测试策略" aria-label="Permalink to “测试策略”">​</a></h2><ul><li>单元测试：对 ViewModel 与 Presenter 独立测试。</li><li>UI 测试：利用 FragmentScenario 模拟生命周期，结合 Espresso/Compose Test。</li><li>集成测试：在导航图中验证深层链接、返回栈与参数传递。</li></ul><h2 id="常见问题排查" tabindex="-1">常见问题排查 <a class="header-anchor" href="#常见问题排查" aria-label="Permalink to “常见问题排查”">​</a></h2><ul><li>IllegalStateException：确认在正确的生命周期阶段提交事务，避免在保存状态后调用。</li><li>Fragment 重叠：检查事务是否重复 <code>add</code>，或使用 <code>replace</code> 防止残留。</li><li>内存泄漏：确保匿名类、Handler、LiveData 观察者在适当阶段移除。</li></ul><p>通过统一的生命周期管理、清晰的事务封装与现代 Jetpack 组件的结合，Fragment 能够灵活支撑多场景界面需求，同时保持良好的可维护性。</p>',24)])])}const p=a(l,[["render",t]]);export{g as __pageData,p as default};
